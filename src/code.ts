/**
 * Main plugin code - refactored version
 *
 * Responsibilities:
 * - Plugin initialization
 * - UI loading
 * - Message routing
 * - Handler orchestration
 */

import { MessageHandler } from './lib/message-handler';
import { setGitHubRef } from './lib/github';
import { logger } from './lib/utils';
import { PLUGIN_MESSAGES, type UIMessage } from './types';
import {
  handleCategoryGeneration,
  logCumulativeChangeStatus,
  type CategoryGenerationConfig,
  type CumulativeChangeData,
} from './handlers';

/**
 * Icon list metadata generated by scripts/update-icon-list.ts
 * Contains commit SHA for tracking which version of icons we're using
 * @ts-ignore - JSON import
 */
import iconListMetadata from './lib/icons/icon-list-metadata.json';

/**
 * Icon changes data (optional) - tracks which icons changed between commits
 * Generated by external scripts when updating icon versions
 * Used for optimization: only update changed icons
 * @type {IconChangesData | null}
 */
// @ts-ignore - JSON import (optional - may not exist)
let iconChangesData: {
  changedIcons?: string[];
  newIcons?: string[];
  oldCommit?: string;
  newCommit?: string;
  totalIcons?: number;
} | null = null;
try {
  iconChangesData = require('../icon-changes.json');
} catch {
  // icon-changes.json doesn't exist - will process all icons
  iconChangesData = null;
}

/**
 * Cumulative icon changes data (optional) - tracks changes across multiple commit hops
 * Used when skipping multiple versions (e.g., v1 -> v3 without processing v2)
 * Enables accurate change tracking even with non-sequential updates
 * @type {CumulativeChangeData | null}
 */
let iconChangesCumulative: CumulativeChangeData | null = null;
try {
  iconChangesCumulative = require('../icon-changes-cumulative.json') as CumulativeChangeData;
} catch {
  // No cumulative data - will use direct icon-changes.json only
  iconChangesCumulative = null;
}

/**
 * Commit SHA from the icon list metadata
 * Ensures all SVG URLs point to the exact commit that was used to generate the icon list
 * This guarantees consistency between the icon list and the actual SVG files fetched
 * @const {string}
 */
const COMMIT_SHA = (iconListMetadata as { commitSha: string }).commitSha;
setGitHubRef(COMMIT_SHA);
logger.info(`Plugin initialized with commit SHA: ${COMMIT_SHA.substring(0, 7)}`);

// Log icon changes delta if available for optimization tracking
logCumulativeChangeStatus(iconChangesData, iconChangesCumulative);

/**
 * Initialize and show the plugin UI
 * UI HTML is loaded from dist/ui.html via manifest.json "ui" field
 * The __html__ variable is automatically populated by Figma's plugin system
 */
figma.showUI(__html__, {
  width: 400,
  height: 600,
  themeColors: true,
});

/**
 * Send initial data to UI after a short delay to ensure UI is fully loaded
 * Includes page names for smart category selection dropdown
 */
setTimeout(() => {
  const pageNames = figma.root.children.map((page) => page.name);
  figma.ui.postMessage({
    type: PLUGIN_MESSAGES.INIT,
    message: 'Plugin initialized',
    pageNames,
  });
}, 100);

/**
 * Cancellation flag checked during long-running operations
 * Set to true when user clicks cancel button in UI
 * Handlers should check this periodically and gracefully stop
 * @type {boolean}
 */
let isCancelled = false;

/**
 * Message handler for non-generation messages (testing, utilities, etc.)
 * Handles: CHECK_EXISTING, RUN_PERFORMANCE_TEST, TEST_SINGLE_ICON
 * @type {MessageHandler}
 */
const messageHandler = new MessageHandler();

/**
 * Message structure for START_GENERATION command
 * Sent from UI when user initiates icon generation for a category
 *
 * @interface StartGenerationMessage
 * @property {string} type - Always 'START_GENERATION'
 * @property {string} category - Category name (e.g., "Set 1: 10k-air")
 * @property {object} categoryData - Icon range boundaries
 * @property {string} categoryData.firstIcon - First icon in category (inclusive)
 * @property {string} categoryData.lastIconExclusive - Last icon boundary (exclusive)
 * @property {number} [testIconCount] - Optional: limit icon count for testing
 */
interface StartGenerationMessage {
  type: 'START_GENERATION';
  category: string;
  categoryData: { firstIcon: string; lastIconExclusive: string };
  testIconCount?: number;
}

/**
 * Main message handler - routes UI messages to appropriate handlers
 * Supports:
 * - INIT: Plugin initialization status
 * - START_GENERATION: Category-based icon generation
 * - CANCEL: User cancellation request
 * - Other: Delegated to MessageHandler
 *
 * @param {object} msg - Message from UI with type and payload
 * @returns {Promise<void>}
 */
figma.ui.onmessage = async (msg: { type: string; [key: string]: unknown }) => {
  logger.info('Received from UI:', { type: msg.type });

  try {
    switch (msg.type) {
      case 'INIT':
        figma.ui.postMessage({
          type: 'STATUS',
          message: 'Plugin initialized',
        });
        break;

      case 'START_GENERATION': {
        // Reset cancellation flag
        isCancelled = false;

        // Type assertion - msg is checked at runtime via switch
        const startMsg = msg as unknown as StartGenerationMessage;

        // Create generation config
        const genConfig: CategoryGenerationConfig = {
          commitSha: COMMIT_SHA,
          iconChangesData,
          iconChangesCumulative,
          isCancelled: () => isCancelled,
        };

        // Call extracted handler
        await handleCategoryGeneration(startMsg, genConfig);
        break;
      }

      case 'CANCEL':
        logger.info('Cancellation requested');
        isCancelled = true;
        figma.ui.postMessage({
          type: PLUGIN_MESSAGES.PROGRESS_UPDATE,
          message: 'Cancelling generation...',
        });
        break;

      default:
        // Type-safe cast: msg conforms to UIMessage for messages handled by MessageHandler
        await messageHandler.handleMessage(msg as UIMessage);
    }
  } catch (error) {
    logger.error('Error handling message:', error);
    figma.ui.postMessage({
      type: 'ERROR',
      message: String(error),
    });
  }
};
