#!/usr/bin/env tsx
/**
 * PHASE 2: Generate Categories
 *
 * Generates evenly distributed category boundaries from the validated icon list.
 *
 * This script:
 * 1. READS from src/lib/all-icons-data.json (generated by update-icon-list.ts)
 * 2. Creates ~26 categories with smart 3-char prefix boundaries
 * 3. Writes category definitions to:
 *    - category-mapping.json (icon â†’ category map for validation)
 *    - categories-summary.json (category metadata for UI)
 *
 * This script should NEVER fetch from GitHub - it reads from the local file.
 *
 * Usage:
 *   tsx scripts/generate-categories.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function generateCategories() {
  console.log('Creating evenly distributed categories...\n');

  try {
    // Read from the SINGLE SOURCE OF TRUTH (generated by update-icon-list.ts)
    const allIconsJsonPath = path.join(
      __dirname,
      '..',
      'src',
      'lib',
      'icons',
      'all-icons-data.json'
    );
    const allIcons: string[] = JSON.parse(fs.readFileSync(allIconsJsonPath, 'utf-8'));

    const outputDir = path.join(__dirname, '..');
    const categoryMappingPath = path.join(outputDir, 'category-mapping.json');
    const categoriesSummaryPath = path.join(outputDir, 'src', 'data', 'categories-summary.json');

    // Check if existing category mapping exists
    let existingMapping: Record<string, string> = {};
    let hasExistingMapping = false;

    if (fs.existsSync(categoryMappingPath) && fs.existsSync(categoriesSummaryPath)) {
      existingMapping = JSON.parse(fs.readFileSync(categoryMappingPath, 'utf-8'));
      // existingCategories loaded but not currently used - available for future enhancements
      hasExistingMapping = true;
      console.log('ðŸ“‹ Found existing category mapping - will preserve existing assignments');
      console.log(`   ${Object.keys(existingMapping).length} icons already assigned\n`);
    }

    const totalIcons = allIcons.length;
    const targetCategories = 27; // Target number
    const iconsPerCategory = Math.floor(totalIcons / targetCategories); // ~152

    console.log(`Total icons: ${totalIcons}`);
    console.log(`Target categories: ${targetCategories}`);
    console.log(`Target per category: ~${iconsPerCategory}\n`);

    // Strategy: Preserve existing assignments, only assign new icons
    const categories: Array<{
      name: string;
      icons: string[];
      count: number;
      lastIconExclusive: string;
    }> = [];

    if (hasExistingMapping) {
      // PRESERVE EXISTING ASSIGNMENTS - Never move icons!
      console.log('ðŸ”’ Preserving existing icon assignments (no icons will be moved)\n');

      // Identify new icons
      const newIcons = allIcons.filter((icon) => !existingMapping[icon]);
      console.log(`ðŸ†• Found ${newIcons.length} new icons to assign\n`);

      // Rebuild categories from existing mapping
      const categoryIconMap = new Map<string, string[]>();
      for (const [icon, category] of Object.entries(existingMapping)) {
        // Only include icons that still exist in all-icons list
        if (allIcons.includes(icon)) {
          if (!categoryIconMap.has(category)) {
            categoryIconMap.set(category, []);
          }
          categoryIconMap.get(category)!.push(icon);
        }
      }

      // Sort icons within each category alphabetically
      for (const icons of Array.from(categoryIconMap.values())) {
        icons.sort();
      }

      // Get category names in order
      const categoryNames = Array.from(categoryIconMap.keys()).sort((a, b) => {
        // Extract category number for sorting (e.g., "Set 1: ..." -> 1)
        const numA = parseInt(a.split(':')[0].replace('Set ', ''));
        const numB = parseInt(b.split(':')[0].replace('Set ', ''));
        return numA - numB;
      });

      // Assign new icons to categories based on alphabetical order
      if (newIcons.length > 0) {
        console.log(
          'ðŸ“š Assigning new icons alphabetically (like adding books to library shelves)...\n'
        );

        // Build category metadata with boundaries
        const categoryMetadata = categoryNames.map((name) => {
          const icons = categoryIconMap.get(name)!;
          return {
            name,
            icons,
            count: icons.length,
            firstIcon: icons[0],
            lastIcon: icons[icons.length - 1],
          };
        });

        // Assign each new icon based on alphabetical position
        for (const newIcon of newIcons) {
          let assignedCategory: (typeof categoryMetadata)[0] | null = null;

          // Find where this icon fits alphabetically
          for (let i = 0; i < categoryMetadata.length; i++) {
            const cat = categoryMetadata[i];

            // Case 1: Icon falls within this category's range
            if (newIcon >= cat.firstIcon && newIcon <= cat.lastIcon) {
              assignedCategory = cat;
              break;
            }

            // Case 2: Icon falls before this category (between previous and current)
            if (newIcon < cat.firstIcon) {
              if (i === 0) {
                // Before first category - add to first category
                assignedCategory = cat;
              } else {
                // Between two categories - choose the smaller one
                const prevCat = categoryMetadata[i - 1];
                assignedCategory = prevCat.count <= cat.count ? prevCat : cat;
              }
              break;
            }
          }

          // Case 3: Icon falls after all categories - add to last category
          if (!assignedCategory) {
            assignedCategory = categoryMetadata[categoryMetadata.length - 1];
          }

          // Add icon to chosen category
          assignedCategory.icons.push(newIcon);
          assignedCategory.icons.sort(); // Re-sort to maintain alphabetical order
          assignedCategory.count++;

          // Update boundaries
          assignedCategory.firstIcon = assignedCategory.icons[0];
          assignedCategory.lastIcon = assignedCategory.icons[assignedCategory.icons.length - 1];

          console.log(
            `   ${newIcon} â†’ ${assignedCategory.name} (now ${assignedCategory.count} icons, ${assignedCategory.firstIcon}...${assignedCategory.lastIcon})`
          );

          // Update the map
          categoryIconMap.set(assignedCategory.name, assignedCategory.icons);
        }

        console.log('');
      }

      // Build final categories array maintaining sort order
      for (const categoryName of categoryNames) {
        const icons = categoryIconMap.get(categoryName)!;
        const firstIcon = icons[0];
        const lastIconInCategory = icons[icons.length - 1];

        // Find the next icon after this category for exclusive boundary
        const lastIconIndex = allIcons.indexOf(lastIconInCategory);
        const lastIcon =
          lastIconIndex + 1 < allIcons.length ? allIcons[lastIconIndex + 1] : '__END__';

        // Extract set number and regenerate name with zero-padding
        const setNumberMatch = categoryName.match(/^(?:Set|Cat) (\d+):/);
        let updatedCategoryName = categoryName;
        if (setNumberMatch) {
          const setNumber = parseInt(setNumberMatch[1]);
          const firstName = firstIcon.substring(0, Math.min(3, firstIcon.length));
          const lastName = lastIconInCategory.substring(0, Math.min(3, lastIconInCategory.length));
          updatedCategoryName = `Set ${String(setNumber).padStart(2, '0')}: ${firstName}-${lastName}`;
        }

        categories.push({
          name: updatedCategoryName,
          icons: icons,
          count: icons.length,
          lastIconExclusive: lastIcon,
        });
      }
    } else {
      // INITIAL GENERATION - Create fresh categories with even distribution
      console.log('ðŸ†• No existing mapping - creating fresh categories\n');

      let currentIndex = 0;
      let categoryNumber = 1;

      while (currentIndex < allIcons.length) {
        const startIndex = currentIndex;
        let endIndex = Math.min(currentIndex + iconsPerCategory, allIcons.length);

        // Adjust end to find a natural breaking point (different 3-char prefix)
        // IMPORTANT: ALWAYS find a prefix boundary - no ambiguous splits allowed!
        if (endIndex < allIcons.length) {
          const getPrefix = (icon: string) => icon.substring(0, Math.min(3, icon.length));
          const targetPrefix = getPrefix(allIcons[endIndex]);

          // Look ahead until we find a prefix change (no limit - must find one!)
          let foundAhead = false;
          for (let i = 0; endIndex + i < allIcons.length; i++) {
            if (getPrefix(allIcons[endIndex + i]) !== targetPrefix) {
              endIndex = endIndex + i;
              foundAhead = true;
              break;
            }
          }

          // If looking ahead made the category too large, try looking back instead
          if (foundAhead && endIndex - startIndex > iconsPerCategory * 1.5) {
            // Look back for a prefix change
            for (let i = 1; endIndex - i > startIndex; i++) {
              const prevPrefix = getPrefix(allIcons[endIndex - i]);
              const currentPrefix = getPrefix(allIcons[endIndex - i + 1]);
              if (prevPrefix !== currentPrefix) {
                endIndex = endIndex - i + 1;
                break;
              }
            }
          }
        }

        const categoryIcons = allIcons.slice(startIndex, endIndex);
        const firstIcon = categoryIcons[0];
        const lastIconInCategory = categoryIcons[categoryIcons.length - 1]; // Last INCLUDED icon
        // EXCLUSIVE boundary for getIconRange: next icon, or '__END__' for last category
        const lastIcon = endIndex < allIcons.length ? allIcons[endIndex] : '__END__';

        // Create descriptive name based on range [inclusive - inclusive] for display
        const firstName = firstIcon.substring(0, Math.min(3, firstIcon.length));
        const lastName = lastIconInCategory.substring(0, Math.min(3, lastIconInCategory.length));

        // Consistent naming format for all categories (zero-padded for proper sorting in Figma)
        const categoryName = `Set ${String(categoryNumber).padStart(2, '0')}: ${firstName}-${lastName}`;

        categories.push({
          name: categoryName,
          icons: categoryIcons,
          count: categoryIcons.length,
          lastIconExclusive: lastIcon, // Store exclusive boundary for getIconRange
        });

        currentIndex = endIndex;
        categoryNumber++;
      }
    } // End if/else for existing mapping

    // Display results
    console.log('\n=====================================');
    console.log(
      hasExistingMapping
        ? 'UPDATED SETS (existing assignments preserved)'
        : 'EVENLY DISTRIBUTED SETS'
    );
    console.log('=====================================');
    console.log('Set# | Name              | Icons | Components | First...Last');
    console.log('-----|-------------------|-------|------------|-------------');

    categories.forEach((cat) => {
      const components = cat.count * 504;
      const first = cat.icons[0];
      const last = cat.icons[cat.icons.length - 1];
      const catNum = cat.name.split(':')[0].padEnd(4);
      const catName = cat.name.split(':')[1].trim().padEnd(17);

      console.log(
        `${catNum} | ${catName} | ${cat.count.toString().padStart(5)} | ${components.toString().padStart(10)} | ${first}...${last}`
      );
    });

    // Statistics
    const counts = categories.map((c) => c.count);
    const max = Math.max(...counts);
    const min = Math.min(...counts);
    const avg = Math.round(counts.reduce((a, b) => a + b, 0) / counts.length);
    const stdDev = Math.round(
      Math.sqrt(counts.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / counts.length)
    );

    console.log('\n=====================================');
    console.log('STATISTICS');
    console.log('=====================================');
    console.log(`Total Sets: ${categories.length}`);
    console.log(`Min icons: ${min} (${min * 504} components)`);
    console.log(`Max icons: ${max} (${max * 504} components)`);
    console.log(`Average: ${avg} (${avg * 504} components)`);
    console.log(`Std Dev: ${stdDev}`);
    console.log(`Range: ${max - min} icons`);

    // Memory estimates
    console.log('\n=====================================');
    console.log('MEMORY ESTIMATES (based on real-world measurements)');
    console.log('=====================================');
    console.log('Baseline: Set 8 (148 icons Ã— 504 variants = 74,592 components) @ ~21.5% memory');
    console.log('Note: Actual memory usage can vary Â±20% between sessions and sets');
    const memoryPerComponent = 21.5 / 74592;
    categories.forEach((cat) => {
      const components = cat.count * 504;
      const estimatedMemory = (components * memoryPerComponent).toFixed(1);
      console.log(`${cat.name}: ~${estimatedMemory}% memory`);
    });

    // Alternative: Pure alphabetical split
    console.log('\n=====================================');
    console.log('ALTERNATIVE: Pure Sequential Split');
    console.log('=====================================');

    for (let i = 0; i < targetCategories; i++) {
      const start = i * iconsPerCategory;
      const end = Math.min(start + iconsPerCategory, allIcons.length);
      const catIcons = allIcons.slice(start, end);
      const components = catIcons.length * 504;
      const estimatedMemory = (components * memoryPerComponent).toFixed(1);

      console.log(
        `Page ${(i + 1).toString().padStart(2)}: ` +
          `${catIcons.length} icons = ${components} components (~${estimatedMemory}% memory) ` +
          `[${catIcons[0]} to ${catIcons[catIcons.length - 1]}]`
      );
    }

    // Save the category mapping
    const categoryMapping: Record<string, string> = {};
    categories.forEach((cat) => {
      cat.icons.forEach((icon) => {
        categoryMapping[icon] = cat.name;
      });
    });

    fs.writeFileSync(categoryMappingPath, JSON.stringify(categoryMapping, null, 2));
    fs.writeFileSync(
      categoriesSummaryPath,
      JSON.stringify(
        categories.map((c) => ({
          name: c.name,
          count: c.count,
          components: c.count * 504,
          firstIcon: c.icons[0],
          lastIcon: c.icons[c.icons.length - 1], // Actual last icon in set (for display)
          lastIconExclusive: c.lastIconExclusive, // Exclusive boundary for getIconRange (internal use)
          sample: c.icons.slice(0, 5),
        })),
        null,
        2
      )
    );

    console.log('\nâœ… Category mapping saved to category-mapping.json');
    console.log('âœ… Summary saved to src/data/categories-summary.json');
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

generateCategories();
